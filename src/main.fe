use erc20_token::ERC20

struct Beneficiary {
	pub addr: address
	pub share: u256
}

contract Splitter {

  _beneficiaries: Map<u256, Beneficiary>
  _beneficiaryCounter: u256
  _shareSum: u256
  _locked: bool
  _onlySplitAfterLocked: bool
  _lockUntilTimestamp: u256
  _owner: address

  pub fn __init__(mut self, mut ctx: Context, onlySplitAfterLocked: bool, lockUntilTimestamp: u256) {
    self._owner = ctx.msg_sender()
    self._onlySplitAfterLocked = onlySplitAfterLocked
    self._lockUntilTimestamp = lockUntilTimestamp
  }

  pub fn addAddress(mut self, ctx: Context, addr: address, share: u256) {
    assert ctx.msg_sender() == self._owner
    assert not self._locked

	  self._beneficiaryCounter += 1
	  self._beneficiaries[self._beneficiaryCounter] = Beneficiary(addr:addr, share:share)
	  self._shareSum+=share
  }

  pub fn removeAddress(mut self, ctx: Context, i: u256) {
    assert ctx.msg_sender() == self._owner
    assert not self._locked
	  assert i <= self._beneficiaryCounter 

	  if i!=self._beneficiaryCounter{
      let lastAddress: Beneficiary = self._beneficiaries[self._beneficiaryCounter].to_mem()
      self._beneficiaries[i] = lastAddress
	  }
	  self._beneficiaryCounter -= 1
  }
  
  pub fn lock(mut self, ctx: Context) {
    assert ctx.msg_sender() == self._owner
    self._locked = true
  }

  pub fn splitBalance(mut self, mut ctx: Context) {
    assert (self._onlySplitAfterLocked and self._locked) or (not self._onlySplitAfterLocked)
    assert self._lockUntilTimestamp < ctx.block_timestamp()

		let initBalance: u256 = ctx.balance_of(ctx.self_address())

		let i: u256 = 0
		while i<self._beneficiaryCounter {
			ctx.send_value(to: self._beneficiaries[i].addr, wei: self._beneficiaries[i].share*initBalance/self._shareSum)
      i+=1
		}
		ctx.send_value(to: self._beneficiaries[i].addr, wei: ctx.balance_of(ctx.self_address()))
  }


  pub fn splitTokensBalance(mut self, mut ctx: Context, tokenAddress: address) {
    assert (self._onlySplitAfterLocked and self._locked) or (not self._onlySplitAfterLocked)
    assert self._lockUntilTimestamp < ctx.block_timestamp()

		let mut token:ERC20 = ERC20(tokenAddress)
		let initTokens: u256 = token.balanceOf(ctx.self_address())

		let mut i: u256 = 0
		while i<self._beneficiaryCounter {
			token.transfer(ctx, recipient: self._beneficiaries[i].addr, value:self._beneficiaries[i].share * initTokens / self._shareSum)
			i+=1
		}
		token.transfer(ctx, recipient: self._beneficiaries[i].addr, value: token.balanceOf(ctx.self_address()))
  }

  pub fn checkIfEqualSplit(self) -> bool {
		let mut i: u256 = 1
		let mut equalFlag: bool = true
		while i<=self._beneficiaryCounter and equalFlag==true {
			if self._beneficiaries[i].share != self._beneficiaries[i-1].share{
        equalFlag = false
      }
			i+=1
		}
		return equalFlag
  }


}

